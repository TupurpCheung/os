### 30天自制操作系统实践



#### 第一天
+ 程序的起始部分是固定的，是因为对于FAT12格式的软盘而言，必须以这个代码开头
+ 软盘共有两个磁头（即有两面），每面都有80个柱面（由外向内的圆，柱面依次为0、1、...79），每个柱面有18个扇区，每个扇区的大小为512bytes
+ 所以一个软盘的大小为 2 * 512 * 80 * 18 = 1440KB = 1.44MB 
+ 而BIOS主板在加载软盘的第一个扇区时，如果第一个扇区最后两个字节是`55AA`，则认为此扇区为启动区（IPL）
+ 启动区太小了，根本无法装下操作系统，所以都是启动区去加载真正的操作系统

#### 第二天
+ 寄存器
  + AX 累加寄存器
  + CX 计数寄存器
  + DX 数据寄存器
  + BX 基址寄存器
  + SP 栈指针寄存器
  + BP 基址指寄存器
  + SI 源地址寄存器
  + DI 目的地址寄存器
 
+ 段寄存器
  + ES 附加段寄存器
  + CS 代码段寄存器
  + SS 栈段寄存器
  + DS 数据段寄存器

+ 为什么是0x7C00
内存中的地址也并不是可以随便使用的，总之IBM规定了0x7c00-0x7dff这512字节地址用来存放启动区的内容

#### 第三天
+ INT 0x13 中断，用于磁盘读、写、扇区校验（verify），以及寻道（seek）
+ JC 如果进位是1，就跳转
+ JNC 如果进位不是1，就跳转
+ C0-H0-S1的含义
  + C，cylinder-柱面0，从0开始，共80个柱面
  + H，head-磁头，从0开始，共两个磁头
  + S，sector-扇区，从1开始，共18个扇区
+ 段寄存器寻址`ES:BX`，真正的地址为 `ES*16  + BX`
+ BIOS将软盘的第一个扇区，即启动区（IPL）加载到内存0x7c00到0x7dff处
+ 启动区（IPL）把软盘的前10个柱面加载到内存的0x8000处
+ 记住：0x8000到0x8200的位置存放的是启动区(IPL的内容)，并不属于真正操作系统的一部分
+ 作者为何使用0x8000以后的内存，纯粹是因为这个地方没有别的程序使用
+ 一般向一个空软盘保存文件时，文件的内容会写在0x4200以后的地方
+ 假设软盘上0x4200以后的地方是我们真正的操作系统，且软盘的前10个柱面被加载到了内存0x8000处，则操作系统在内存中的位置为0x8000+0x4200=`0xc200`处
+ c语言编译为机器语言步骤：c->gas->nas->obj->bim->hrb...


#### 第四天
+ 指针（地址）定义，不论指针是用于指向何种类型的值（char-1个字节，short-2个字节，int-4个字节），至少在32位系统中，指针本身都占用4个字节（32位），只有这样，
才能定位4GB内存。也正因为此，在32位操作系统中，配置超过4G的内存是没有意义的，操作系统根本访问不到

+ **对C语言指针的理解**
  + 指针的定义 	`int *p`，实际定义的就是一个p变量，只是这个变量用于表示地址（地址变量）
	+ 如下的程序，CPU在for循环中执行的动作是`MOV ECX,p	MOV [ECX] i`
    ```
    int i;    /**32位的整数，即4个字节DWORD*/
    char *p;	/**char类型的指针，用于Byte型地址*/

    for	(i = 0xa0000;	i <= 0xaffff;	i++)	{
	    p = i;
	    *p = i | 0x0f;
    }
    ```
	+ `*p`的这个p值是放在CPU的寄存器(比如EXC)中的，更新寄存器中的值使用	`p = 某个值`，`*p = i`就相当于于`[ECX] = 内存p这个位置的值修改为i`
	+ 所以C语言是个值传递的程序
+ ESP也许存放的是形参所在的内存地址，根据参数所占用的空间，不停的加，放到就可以得到每个形参的内存地址
+ 关于调色板的问题，io_out8是向端口输出，而不是内存。VGA八位真彩模式的要求就是向0x03c8输入调色板序号，0x03c9输入序号对应的颜色
+ 由于VGA八位真彩模式的一个像素点只有八位，最多能表示256种颜色。但无法用于表示RGB颜色（需24位来表示）。所以使用了调色板，像素点存储调色板的序号（8位），序号
对应的RGB位颜色则存储在调色板中。且每个序号对应的RGB颜色可以由程序员自己设定。